# 1. 프로그래밍 언어를 분류하는 다양한 기준
프로그래밍 언어는 다양한 기준으로 분류할 수 있다.

##  1.1 저수준(Low Level) 언어 vs 고수준(High Level) 언어

### 1.1.1 저수준 언어
- 저수준 언어는 **기계어**와 가깝고, 가장 기계어에 가까운 것은 0과 1로 구성된 바이너리 이진수이다.
- 대표적인 언어로는 **어셈블리어**가 있으며 배우기 매우 어렵다.
- 어셈블리어는 CPU마다 다른데, 대표적으로는 인텔 CPU 계열의 **X86 어셈블리어**와 ARM CPU 계열의 **ARM 어셈블리어**가 있다.

### 1.1.2 고수준 언어
- **사람의 언어**와 가까운 언어이며, 배우기 쉽고 활용도가 높다.
- 대표적인 언어로는 Javascript, Kotlin, Java, Python 등이 있다.


## 1.2 인터프리터(Interpreter) vs 컴파일러(Compiler)

### 1.2.1 인터프리터 언어
- 사용자와 CPU 간의 **통역역할**을 해주는 인터프리터를 활용하는 프로그래밍 언어
- 사용자가 작성한 코드를 인터프리터가 **기계어로 번역**하여 CPU에 전달
- CPU는 기계어로 번역된 코드를 실행하고 그 결과를 인터프리터에 다시 전달
- 인터프리터는 코드 실행 결과를 다시 사용자에게 출력
- 인터프리터 언어는 코드를 **한 줄씩 해석하고 실행**한다.
- 대표적인 언어로는 Javascript와 Python 등이 있다.

### 1.2.2 컴파일러 언어
- 인터프리터와 다르게 **모든 코드를 한 번에 기계어로 해석**하여 하나의 파일로 CPU에 전달
- 해석하는 과정을 컴파일이라고 하며, 컴파일 된 파일을 CPU가 전달받아 실행
- **정적타입 언어**는 주로 컴파일러형 언어인 경우가 많다.
- 대표적인 언어로는 C, Java, Rust 등이 있다.

## 1.3 동적타입(Dynamic Typed) 언어 vs 정적타입(Static Typed) 언어

### 1.3.1 동적타입 언어
- **실행단계**에서 할당된 타입을 확인해서 타입이 결정된다.

### 1.3.2 정적타입 언어
- **컴파일단계**에서 타입이 결정된다.
- 코드에 미리 변수의 타입을 명시하여 컴파일러에게 알려줘야 한다, 그렇지 않으면 에러를 발생시킨다.

### 1.3.3 정적타입 언어의 장점
- 타입 불일치로 인한 버그를 컴파일 단계에서 빠르게 찾아 해결할 수 있으므로, **유지보수성**이 좋아진다.

### 1.3.4 Typescript
- 본래 Javascript는 HTML에 동적인 요소를 부여하기 위한 언어
- 최근에 들어서 Javascript를 이용해 메가 어플리케이션, 백엔드, 모바일&데스크탑 앱 등 거의 모든 분야에 활용되고 있다.
- 이로 인해, 하나의 어플리케이션을 여러 개발자가 개발하게 되며, 동적타입 언어의 단점이 드러났다.
- Typescript는 Javascript에 정적 타입의 이점을 얹은 superset 언어이다.
- .ts 확장자로 작성된 파일을 tsc 즉, Typescript Compiler를 이용해 컴파일하여 .js 파일을 반환한다.
- 이 **컴파일 과정에서 타입 에러들을 미리 알고 해결** 할 수 있다.
- 특정 데이터의 최종형태를 미리 지정하여 알 수 있기 때문에 위와 같이 미리 해결 할 수 있다.
- 하지만, .ts 파일로 작성했다고 해도 런타임에서는 **.js 파일을 사용**하기 때문에, 런타임에서 변수의 타입이 변경되는 것은 막을 수 없는 것이 **Typescript의 한계**이다.
```ts
// js
const car = {
    wheel: 4,
    door: 4,
}

car.go = true; // not Error

// ts
interface Car {
    wheel: number;
    door: number;
}

const car: Car = {
    wheel: 4,
    door: 4
}

car.go = true; // Property 'go' does not exist on type 'Car'.
```

## 1.4 절차지향 vs 객체지향 vs 함수형
프로그래밍 언어는 프로그래밍 패러다임을 기준으로 나누는 것도 가능하다.

### 1.4.1 절차지향 프로그래밍
- 절차를 함수로 만들어 **특정 문제를 순서대로 해결**
- 현재 시점에서는 수치 계산이나 과학적 연구에 많이 사용되며, **알고리즘 개발에 많이 사용**된다
- ❓ 알고리즘에 절차지향 프로그래밍이 많이 사용되는 이유는, 많은 알고리즘은 순차적인 단계를 통해 문제를 해결하는 방법이기 때문이다.

### 1.4.2 객체지향 프로그래밍
- 모든 것을 객체로 표현하며, 객체에는 데이터와 메서드를 포함할 수 있고, 이를 **캡슐화**라고 한다.
- 예를 들면, 토끼를 객체로 표현하기 위해 토끼에 대한 **정보(데이터)** 와 토끼가 할 수 있는 **행위(메서드)를 포함** 할 수 있다.
```js
const rabbit = {
    x: 0,
    y: 0,
    foot: 4,
    go: () => {
       rabbit.x = rabbit.x + 1;
       return;
    },
    back: () => {
       rabbit.y = rabbit.y + 1;
       return;
    }
}
```
- 순서가 아닌 **객체 간 관계**가 중요.
- **UML 다이어그램**을 이용한 개발방식을 사용.
- 가장 큰 특징은 **상속**을 할 수 있는 점이지만, 양날의 검이 될 수 있다.
- 이유는, 관계와 상속으로 프로그램을 설계하는 일은 굉장히 어려운데, 객체지향은 실생활의 모습을 추상화하여 문제를 해결하기 위한 방식인데, **실생활에서 문제를 해결 할 때 보통은 상속이라는 개념을 이용해서 해결하지 않기 때문**이다.
- 이러한 이유로 객체지향 프로그래밍이라 하여도 **상속은 필수적인 것은 아니라고** 볼 수 있고, 실제로 Go라는 프로그래밍 언어는 상속을 지원하지 않고 합성만을 지원한다.

### 1.4.3 함수형 프로그래밍
 - **카테고리 이론**에 바탕을 두고 있는 프로그래밍 패러다임
 - 카테고리 이론이란 실생활이나 프로그래밍에서의 **모든 문제를 함수 합성으로 추상화하여 해결** 할 수 있다는 이론.
 - **데이터 불변성**을 중요하게 생각하며 변수가 읽기만 가능하기 때문에 멀티스레드 프로그래밍에서 발생할 수 있는 많은 문제를 해결 할 수 있다.
 - 함수 합성에 참여하는 함수는 **순수함수**여야 한다.
 - 순수함수는 외부 요인에 의해 함수의 결과값이 변하지 않는 함수를 뜻하며, 더 쉽게는 같은 값을 함수에 투입시키면 **함수의 반환값이 항상 같음을 의미**한다.
 - **모나드 기법**을 사용하여 순수함수로써 기능을 할 수 있도록 한다.

<br />
<br />
<br />

## ❓ 궁금한 것들 정리

- ❓ CPU 마다 어셈블리어가 만들어지게 된 이유<br />
    - CPU마다 고유한 아키텍쳐가 존재하고, 존재하는 아키텍쳐에 최적화 된 명령어 세트를 가진다. 이렇게 최적화 된 어셈블리어를 사용하면 CPU의 성능과 특성을 최대한으로 활용할 수 있기 때문.
- ❓ 컴파일 시점과 실행 시점은 어떻게 다른지<br />
    - 컴파일러를 통해 프로그래밍 언어로 쓰여진 코드를 기계어로 변환하고 CPU에 전달하는 것을 컴파일이라고 한다. 해당 컴파일 단계에서 오류가 없다면 CPU는 전달받은 기계어 코드를 실행하여 결과를 개발자에게 반환한다. 이 단계를 거친다면 컴파일 시점 이후 오류가 없다면 컴파일 된 파일을 실행하는 순서로 볼 수 있다.
    - 인터프리터 언어는 컴파일 단계가 없기 때문에, 인터프리터를 통해 기계어로 변환한 코드를 CPU에 전달한다.
    - 이러한 특성 때문에, 인터프리터 언어는 실행하기 전까지는 코드 상에서 에러를 발견할 수 없고, 실행속도가 더 빠르다. (한 줄씩 실행 하는 인터프리터 언어의 특성이 있기 때문)
- ❓ 절차지향 프로그래밍이 알고리즘 개발에 사용되는 이유<br />
    - 1.4.1 본문 추가 완료
- ❓ UML 다이어그램 특징 간략 정리<br />
- ❓ 객체지향에서 합성, 상속의 개념은 무엇인지<br />
    - **2.상속과 합성** 내용 정리
- ❓ 멀티스레드 프로그래밍 언어에서 발생할 수 있는 문제들을 함수형 프로그래밍이 어떻게 해결 할 수 있는지<br />
- ❓ 모나드 정리 <br />